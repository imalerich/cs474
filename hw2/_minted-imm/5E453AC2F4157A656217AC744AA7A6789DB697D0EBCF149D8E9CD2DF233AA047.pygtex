\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} Setup \PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}

\PYG{k+kn}{library}\PYG{p}{(}foreach\PYG{p}{)}
\PYG{k+kn}{library}\PYG{p}{(}doParallel\PYG{p}{)}

data \PYG{o}{\PYGZlt{}\PYGZhy{}} read.csv\PYG{p}{(}\PYG{l+s}{\PYGZdq{}magic04.data\PYGZdq{}}\PYG{p}{,} header\PYG{o}{=}\PYG{n+nb+bp}{F}\PYG{p}{,} sep\PYG{o}{=}\PYG{l+s}{\PYGZdq{},\PYGZdq{}}\PYG{p}{)}
train.size \PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{13000} \PYG{c+c1}{\PYGZsh{} Given by homework specification}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} KNN \PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
 
\PYG{c+c1}{\PYGZsh{} Try a bunch of different K\PYGZhy{}values,}
err \PYG{o}{\PYGZlt{}\PYGZhy{}} foreach \PYG{p}{(}K\PYG{o}{=}\PYG{l+m}{1}\PYG{o}{:}\PYG{l+m}{50}\PYG{p}{,} \PYG{l+m}{.}combine \PYG{o}{=} \PYG{k+kt}{c}\PYG{p}{)} \PYG{o}{\PYGZpc{}do\PYGZpc{}} \PYG{p}{\PYGZob{}}
    cl \PYG{o}{\PYGZlt{}\PYGZhy{}} makeCluster\PYG{p}{(}\PYG{l+m}{4}\PYG{p}{)}
    registerDoParallel\PYG{p}{(}cl\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Run KNN 100 times for each K value.}
    \PYG{c+c1}{\PYGZsh{} Each run is independent, so we can speed things up a little}
    \PYG{c+c1}{\PYGZsh{} bit by running it in parallel.}
    k.err \PYG{o}{\PYGZlt{}\PYGZhy{}} foreach \PYG{p}{(}i\PYG{o}{=}\PYG{l+m}{1}\PYG{o}{:}\PYG{l+m}{100}\PYG{p}{,} \PYG{l+m}{.}combine \PYG{o}{=} \PYG{k+kt}{c}\PYG{p}{)} \PYG{o}{\PYGZpc{}dopar\PYGZpc{}} \PYG{p}{\PYGZob{}}
	\PYG{c+c1}{\PYGZsh{} Need to load the library for knn on each thread.}
	\PYG{k+kn}{library}\PYG{p}{(}\PYG{k+kp}{class}\PYG{p}{)}

	data \PYG{o}{\PYGZlt{}\PYGZhy{}} data\PYG{p}{[}\PYG{k+kp}{sample}\PYG{p}{(}\PYG{k+kp}{nrow}\PYG{p}{(}data\PYG{p}{)),]} \PYG{c+c1}{\PYGZsh{} Randomize the data set}

	train \PYG{o}{\PYGZlt{}\PYGZhy{}} data\PYG{p}{[}\PYG{l+m}{1}\PYG{o}{:}train.size\PYG{p}{,} \PYG{l+m}{1}\PYG{o}{:}\PYG{l+m}{10}\PYG{p}{]}
	test \PYG{o}{\PYGZlt{}\PYGZhy{}} data\PYG{p}{[(}train.size\PYG{l+m}{+1}\PYG{p}{)}\PYG{o}{:}\PYG{k+kp}{nrow}\PYG{p}{(}data\PYG{p}{),} \PYG{l+m}{1}\PYG{o}{:}\PYG{l+m}{10}\PYG{p}{]}
	train.cl \PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kp}{factor}\PYG{p}{(}data\PYG{p}{[}\PYG{l+m}{1}\PYG{o}{:}train.size\PYG{p}{,} \PYG{l+m}{11}\PYG{p}{])}
	test.cl \PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kp}{factor}\PYG{p}{(}data\PYG{p}{[(}train.size\PYG{l+m}{+1}\PYG{p}{)}\PYG{o}{:}\PYG{k+kp}{nrow}\PYG{p}{(}data\PYG{p}{),} \PYG{l+m}{11}\PYG{p}{]);}

	predict.cl \PYG{o}{\PYGZlt{}\PYGZhy{}} knn\PYG{p}{(}train\PYG{p}{,} test\PYG{p}{,} train.cl\PYG{p}{,} k\PYG{o}{=}K\PYG{p}{)}
	\PYG{k+kp}{sum}\PYG{p}{(}test.cl \PYG{o}{!=} predict.cl\PYG{p}{)} \PYG{o}{/} \PYG{k+kp}{nrow}\PYG{p}{(}test\PYG{p}{)}
    \PYG{p}{\PYGZcb{}}

    stopCluster\PYG{p}{(}cl\PYG{p}{)}
    \PYG{k+kp}{mean}\PYG{p}{(}k.err\PYG{p}{)}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} This was our best performing k value.}
k \PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kp}{which.min}\PYG{p}{(}err\PYG{p}{)}
min.err \PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kp}{min}\PYG{p}{(}err\PYG{p}{)}
acc \PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{1.0} \PYG{o}{\PYGZhy{}} min.err

\PYG{c+c1}{\PYGZsh{} About 80.975\PYGZpc{}}
\PYG{k+kp}{print}\PYG{p}{(}\PYG{k+kp}{paste}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}KNN \PYGZhy{} Accuracy: \PYGZdq{}}\PYG{p}{,} acc\PYG{p}{))}
 
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} LDA \PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}

\PYG{c+c1}{\PYGZsh{} cl \PYGZlt{}\PYGZhy{} makeCluster(4)}
\PYG{c+c1}{\PYGZsh{} registerDoParallel(cl)}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{} err \PYGZlt{}\PYGZhy{} foreach (i=1:100, .combine = c) \PYGZpc{}dopar\PYGZpc{} \PYGZob{}}
\PYG{c+c1}{\PYGZsh{}     library(MASS)}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     data \PYGZlt{}\PYGZhy{} data[sample(nrow(data)),] \PYGZsh{} Randomize the data set}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     train \PYGZlt{}\PYGZhy{} data[1:train.size, 1:10]}
\PYG{c+c1}{\PYGZsh{}     test \PYGZlt{}\PYGZhy{} data[(train.size+1):nrow(data), 1:10]}
\PYG{c+c1}{\PYGZsh{}     train.cl \PYGZlt{}\PYGZhy{} factor(data[1:train.size, 11])}
\PYG{c+c1}{\PYGZsh{}     test.cl \PYGZlt{}\PYGZhy{} factor(data[(train.size+1):nrow(data), 11]);}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     model \PYGZlt{}\PYGZhy{} lda(x = train, grouping = train.cl)}
\PYG{c+c1}{\PYGZsh{}     predict.cl \PYGZlt{}\PYGZhy{} predict(model, test)\PYGZdl{}class}
\PYG{c+c1}{\PYGZsh{}     sum(test.cl != predict.cl) / nrow(test)}
\PYG{c+c1}{\PYGZsh{} \PYGZcb{}}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{} stopCluster(cl)}
\PYG{c+c1}{\PYGZsh{} acc \PYGZlt{}\PYGZhy{} 1.0 \PYGZhy{} mean(err)}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{} \PYGZsh{} About 78.429\PYGZpc{}}
\PYG{c+c1}{\PYGZsh{} print(paste(\PYGZdq{}LDA \PYGZhy{} Accuracy: \PYGZdq{}, acc))}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} QDA \PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}

\PYG{c+c1}{\PYGZsh{} cl \PYGZlt{}\PYGZhy{} makeCluster(4)}
\PYG{c+c1}{\PYGZsh{} registerDoParallel(cl)}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{} err \PYGZlt{}\PYGZhy{} foreach (i=1:100, .combine = c) \PYGZpc{}dopar\PYGZpc{} \PYGZob{}}
\PYG{c+c1}{\PYGZsh{}     library(MASS)}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     data \PYGZlt{}\PYGZhy{} data[sample(nrow(data)),] \PYGZsh{} Randomize the data set}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     train \PYGZlt{}\PYGZhy{} data[1:train.size, 1:10]}
\PYG{c+c1}{\PYGZsh{}     test \PYGZlt{}\PYGZhy{} data[(train.size+1):nrow(data), 1:10]}
\PYG{c+c1}{\PYGZsh{}     train.cl \PYGZlt{}\PYGZhy{} factor(data[1:train.size, 11])}
\PYG{c+c1}{\PYGZsh{}     test.cl \PYGZlt{}\PYGZhy{} factor(data[(train.size+1):nrow(data), 11]);}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     model \PYGZlt{}\PYGZhy{} qda(x = train, grouping = train.cl)}
\PYG{c+c1}{\PYGZsh{}     predict.cl \PYGZlt{}\PYGZhy{} predict(model, test)\PYGZdl{}class}
\PYG{c+c1}{\PYGZsh{}     sum(test.cl != predict.cl) / nrow(test)}
\PYG{c+c1}{\PYGZsh{} \PYGZcb{}}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{} stopCluster(cl)}
\PYG{c+c1}{\PYGZsh{} acc \PYGZlt{}\PYGZhy{} 1.0 \PYGZhy{} mean(err)}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{} \PYGZsh{} About 78.4276\PYGZpc{}}
\PYG{c+c1}{\PYGZsh{} print(paste(\PYGZdq{}QDA \PYGZhy{} Accuracy: \PYGZdq{}, acc))}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} Naive Bayes (Normal) \PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}

\PYG{c+c1}{\PYGZsh{} cl \PYGZlt{}\PYGZhy{} makeCluster(4)}
\PYG{c+c1}{\PYGZsh{} registerDoParallel(cl)}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{} err \PYGZlt{}\PYGZhy{} foreach (i=1:100, .combine = c) \PYGZpc{}dopar\PYGZpc{} \PYGZob{}}
\PYG{c+c1}{\PYGZsh{}     library(klaR)}
\PYG{c+c1}{\PYGZsh{}     library(caret)}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     data \PYGZlt{}\PYGZhy{} data[sample(nrow(data)),] \PYGZsh{} Randomize the data set}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     train \PYGZlt{}\PYGZhy{} data[1:train.size, 1:10]}
\PYG{c+c1}{\PYGZsh{}     test \PYGZlt{}\PYGZhy{} data[(train.size+1):nrow(data), 1:10]}
\PYG{c+c1}{\PYGZsh{}     train.cl \PYGZlt{}\PYGZhy{} factor(data[1:train.size, 11])}
\PYG{c+c1}{\PYGZsh{}     test.cl \PYGZlt{}\PYGZhy{} factor(data[(train.size+1):nrow(data), 11]);}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     model \PYGZlt{}\PYGZhy{} NaiveBayes(x = train, grouping = train.cl, usekernel=FALSE)}
\PYG{c+c1}{\PYGZsh{}     predict.cl \PYGZlt{}\PYGZhy{} predict(model, test)\PYGZdl{}class}
\PYG{c+c1}{\PYGZsh{}     sum(test.cl != predict.cl) / nrow(test)}
\PYG{c+c1}{\PYGZsh{} \PYGZcb{}}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{} stopCluster(cl)}
\PYG{c+c1}{\PYGZsh{} acc \PYGZlt{}\PYGZhy{} 1.0 \PYGZhy{} mean(err)}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{} \PYGZsh{} About 72.6714\PYGZpc{}}
\PYG{c+c1}{\PYGZsh{} print(paste(\PYGZdq{}Naive Bayes (Normal) \PYGZhy{} Accuracy: \PYGZdq{}, acc))}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} Naive Bayes (Kernel) \PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}

\PYG{c+c1}{\PYGZsh{} cl \PYGZlt{}\PYGZhy{} makeCluster(4)}
\PYG{c+c1}{\PYGZsh{} registerDoParallel(cl)}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{} err \PYGZlt{}\PYGZhy{} foreach (i=1:100, .combine = c) \PYGZpc{}dopar\PYGZpc{} \PYGZob{}}
\PYG{c+c1}{\PYGZsh{}     library(klaR)}
\PYG{c+c1}{\PYGZsh{}     library(caret)}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     data \PYGZlt{}\PYGZhy{} data[sample(nrow(data)),] \PYGZsh{} Randomize the data set}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     train \PYGZlt{}\PYGZhy{} data[1:train.size, 1:10]}
\PYG{c+c1}{\PYGZsh{}     test \PYGZlt{}\PYGZhy{} data[(train.size+1):nrow(data), 1:10]}
\PYG{c+c1}{\PYGZsh{}     train.cl \PYGZlt{}\PYGZhy{} factor(data[1:train.size, 11])}
\PYG{c+c1}{\PYGZsh{}     test.cl \PYGZlt{}\PYGZhy{} factor(data[(train.size+1):nrow(data), 11]);}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{}     model \PYGZlt{}\PYGZhy{} NaiveBayes(x = train, grouping = train.cl, usekernel=TRUE)}
\PYG{c+c1}{\PYGZsh{}     predict.cl \PYGZlt{}\PYGZhy{} predict(model, test)\PYGZdl{}class}
\PYG{c+c1}{\PYGZsh{}     sum(test.cl != predict.cl) / nrow(test)}
\PYG{c+c1}{\PYGZsh{} \PYGZcb{}}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{} stopCluster(cl)}
\PYG{c+c1}{\PYGZsh{} acc \PYGZlt{}\PYGZhy{} 1.0 \PYGZhy{} mean(err)}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{} \PYGZsh{} About 76.2375\PYGZpc{}}
\PYG{c+c1}{\PYGZsh{} print(paste(\PYGZdq{}Naive Bayes (Kernel) \PYGZhy{} Accuracy: \PYGZdq{}, acc))}
\end{Verbatim}
